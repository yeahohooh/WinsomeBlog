---
title: "Go 语言中局部变量的堆栈"
date: 2024-10-16T18:27:39+08:00
draft: false
tags: 
  - Golang
author : winsome
scrolltotop : true
toc : true
mathjax : false
---

在 Go 语言中，局部变量**通常分配在栈上**，栈内存用于**存储局部变量和函数调用信息**。当局部变量的生命周期超出了函数的作用范围，或当局部变量被传递给其他函数且可能被持久化时，Go 的编译器会将其**转移到堆上**，这种机制称为“**逃逸分析**”。

---------

1）**逃逸分析**

在 Go 语言中，逃逸分析是一种**编译时优化技术**，用于确定变量的生命周期及其存储位置（栈或堆）。通过逃逸分析，Go 编译器可以决定哪些变量应该分配在栈上，哪些应该分配在堆上。同时，编译器能优化内存使用，提高程序的性能。

2）**栈分配**

- **局部变量**： 通常情况下，局部变量在函数调用期间分配在栈上。栈分配的变量在函数返回时会自动释放，因此其生命周期仅限于函数的执行期间。
- **栈的优势**： 栈分配通常比堆分配更高效，因为栈的内存管理相对简单，变量的分配和释放操作速度更快。
3）**堆分配**

- **逃逸变量**： 如果局部变量的生命周期超出了其所在的函数作用域（例如：它被返回或被引用到其他地方），则该变量会“**逃逸**”到堆上。堆内存需要显式的垃圾回收来管理，这样变量在函数返回后仍然可以被访问。
- **堆的优势**： 虽然堆分配比栈分配开销大，但它允许变量在函数调用结束后继续存在。

4）**如何逃逸分析**

- **静态分析**： 编译器在编译过程中通过**静态分析确定变量的生命周期**。它会检查变量是否在函数返回后仍然被引用，或者是否存储在全局变量或其他数据结构中，这些都会影响变量是否需要分配在堆上。

- **逃逸分析的例子**：

    **返回值**： 如果你从函数中返回一个局部变量（如**切片或结构体**），这个变量会被分配到堆上，因为它的生命周期超出了函数调用的范围。

    **闭包**：如果一个局部变量被闭包引用，那么这个变量也会逃逸到堆上，因为闭包可能在函数调用结束后继续存在。

    代码示例：


```go
package main

import "fmt"

func main() {
    // 1. 不会逃逸到堆
    a := 10
    fmt.Println(a)

    // 2. 逃逸到堆
    b := newSlice() // newSlice 返回一个切片，该切片的底层数组可能需要在堆上分配
    fmt.Println(b)
}

func newSlice() []int {
    s := make([]int, 0) // s 是一个局部变量
    s = append(s, 1)
    return s // s 的底层数组会逃逸到堆上，因为切片在函数返回后仍然被引用
}
```

**总结**

- **逃逸分析**： 是 Go 编译器用来确定变量在栈上还是堆上分配的机制。通过逃逸分析，编译器能优化内存分配，提高程序的性能。
- **栈 vs 堆**： 栈分配速度快且内存管理简单，但生命周期短；堆分配灵活，能支持较长生命周期，但开销较大。

